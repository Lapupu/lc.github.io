这类图想好dp数组的定义后，自己画一个例子，递推关系就找出来了

##  115.不同的子序列

```cpp
dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]
```

这个dp数组的含义我没有想到，所以没有做出来，其实想到就能解决

接下来是想递推公式，这个题目比较搞的地方在于它是单项的，也就是只能操作字符串s，不能做字符串t，所以递推公式应该为

```cpp
if (s[i - 1] == t[j - 1]) {//相等，应该是二者长度都减去1的次数再加上s减少自己的字符后出现的次数
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
} else {
    dp[i][j] = dp[i - 1][j];//不相等，只有是s减少自己的字符后出现的次数
```

接下来这道题就好解决了

初始化直接按照定义来就ok，注意`dp[0][0]=1`就行

## 583. 两个字符串的删除操作

自己做出来

相似的dp定义

```
dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
```

这道题是双向的，两边的数字都可以删减，所以dp数组的条件为

```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];//相同，那么直接从i-1,j-1得到，无需额外操作
} else {
    dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);//不相同，要加1，两个word都可以缩小
```

初始化按照定义想就能做出来

## 72. 编辑距离

自己做出来，比上道题复杂些

```
dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]
```

这道题本质是单向的，但是操作比较多，把操作对应的递推公式想出来就能做了

```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1]; //相同，那么直接从i-1,j-1得到，无需额外操作
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}//不相同三种方法取最小
```

`dp[i - 1][j - 1]+1 ` 是替代

`dp[i - 1][j]+1`相当于加字母

`dp[i][j-1]+1`相当于减去字母
