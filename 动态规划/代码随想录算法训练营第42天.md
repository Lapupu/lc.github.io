## **完全背包** 

目前，对使用二维数组和一维数组解决这个完全背包问题都懂了，但是没有理解。

对于使用一维数组解决，可以使用两种遍历方法

```cpp
for (int i = 1; i < n; i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
    }
}
```

这种是组合数计算

```cpp
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

这种是排列数计算

## 518.零钱兑换II

这道题和17一零和是比较类似的，我对使用一维数组的方法比较熟悉，这里记录一维数组的思路

`dp[j] += dp[j - coins[i]]` 著名递归公式

这里dp[0] 同样初始为1

本题要求凑成总和的组合数，元素之间明确要求没有顺序，遍历顺序为先物品后背包

这道题还需要注意：使用`uint64_t`数据类型

## 377. 组合总和 Ⅳ

虽说名字是组合总和，但是实际上是求排列，使用排列代码解决它