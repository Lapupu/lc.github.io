## 300.最长递增子序列

### dp数组定义

dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度

因为我们在 做 递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢

### 状态转移方程

```cpp
if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
```

### dp[i]的初始化

全为1，因为至少可以只包含自己

### 确定遍历顺序

从前向后遍历，对于每个dp[i]，遍历i之前的数字进行比较

## 674. 最长连续递增序列

本体大部分与上一道题目相同，只不过状态转移方程需要修改

### 我的做法

```cpp
for(int i=1; i<nums.size();i++){
    for(int j=0; j<i; j++){
        if(nums[i]>nums[j]){
            dp[i] = max(dp[i], dp[j] + 1);
        }
        if(nums[j]>=nums[j+1]){
            dp[i]=1;
        }
    if (dp[i] > result) result = dp[i];
    }
```

我的想法是在上一个代码进行改善，如果出现num变小，那么归为1，我再(nums[j]>=nums[j+1])纠结很久，因为j永远比i小，所以想保证全部都遍历，则这种方法比较合适

但是这种方法显然是对于上个方法的过拟合，实际上我们没有比较在i之前遍历，只需要比较上一个dp就可以

```cpp
for(int i=1; i<nums.size();i++){
    if(nums[i]>nums[i-1]) dp[i]=dp[i-1]+1;
    if (dp[i] > result) result = dp[i];
    }
```

## 718. 最长重复子数组

确定dp数组（dp table）以及下标的含义

```
dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]
```

确定递推公式

```
当A[i - 1] 和B[j - 1]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1
```

dp数组如何初始化

```
dp[i][0] 和dp[0][j]其实都是没有意义的，但是仍要初始化，全为0就可以不影响后面的值
```

要点：

想到用二维数组解决问题

```
dp[i][j]以下标i - 1为结尾的A，和以下标j - 1为结尾的B的最大长度是为了初始化方便，不然还要额外的遍历
```

