## 416. 分割等和子集

这道题目的要验证一个数据集能否平分为两部分，我们转化问题为求能不能装满一个容量为sum/2的背包

1. 确定dp数组以及下标的含义： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为dp[j]。 这里的重量是数值
2. 确定递推公式 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])
3. dp数组如何初始化 在这个题目中直接为0就可以了
4. 确定遍历顺序

经典遍历顺序就行

##  1049.最后一块石头的重量II

这道题与上题的内核是一致的，我们的目的是让两堆石头的重量尽可能的接近，最后让它们相减即可

```cpp
int target = sum / 2;
```

代码技巧上，因为targe取整，所以最后一定小于等于另一堆，`return sum - dp[target] - dp[target];` 所以这种return合理

## 494.目标和

拼劲全力没看懂，明天接着写

## 474.一和零

本题依旧是0，1背包的问题，最多有i个0和j个1的strs的最大子集的大小为`dp[i][j]`，

`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);` 是递归公式，如果我们放这个数组的话，子集数目加1，反之保留之前的值