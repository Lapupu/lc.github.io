## 322. 零钱兑换

这道题目我自己尝试写但是没有写出来，看到答案更好地理解了这个算法

我错误的地方在于

初始化: 我初始化为全是-1，dp[0]=0，但是不如`INT_MAX`有优势

其次是我没有使用`min(dp[j - coins[i]] + 1, dp[j])` ，导致我的算法需要排序（最后也没写出来）

最后是跳过的条件`dp[j - coins[i]] != INT_MAX`没有想到

## 24.完全平方数

自己搞定，可跳过

## 139.单词拆分

好题，自己没做出来，这道题先要逆向思维，不是字符串拆分成wordDict，而是wordDict组成字符串，从而构成一个完全背包的问题（或者不从完全背包的问题来理解，像跳楼梯一样）

代码中，上来构建一个`unordered_set<string>` 实现去重，`dp[i]`数组是长度为i的字符串可拆分为一个或多个字典中的单词

对于递推公式，如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true

对于初始化，`dp[0]=true`，否则不能继续推导

提取字符使用`substr`函数进行

时间复杂度：O(n^3)，空间复杂度：O(n)