# 代码随想录算法训练营第11天

## 150. 逆波兰表达式求值 

使用栈解决这个问题，遇到符号pop两个数字出来，没有把数字push到栈里面

注意都是后面减去前面

代码中的一些细节

```
tokens[i] == "+"; //字符串string使用"",字符char使用''
```

`long long` 和 `int` 都是整数类型，但它们的存储范围不同。

| 类型        | 大小（字节） | 范围                                    |
| ----------- | ------------ | --------------------------------------- |
| `int`       | 4 字节       | −231-2^{31}−231 到 231−12^{31} - 1231−1 |
| `long long` | 8 字节       | −263-2^{63}−263 到 263−12^{63} - 1263−1 |

`stoll` 是 C++ 标准库中一个函数，定义在头文件 `<string>` 中。它的作用是将一个字符串转换为 `long long` 类型的整数。

### 239. 滑动窗口最大值

这道题的重点是定义一下队列实现对应的功能，有点难度

### `std::deque` 类及其函数解释

`std::deque` 是 C++ 标准库中的一个容器类，定义在头文件 `<deque>` 中。它的全称是 **Double-Ended Queue（双端队列）**，表示可以在容器的两端高效地插入和删除元素。

与 `std::vector` 类似，`std::deque` 也是一个动态数组，但它在两端的操作（插入和删除）更加高效。

### `std::deque` 的特点

1. **双端操作：**
   - 支持在队列的头部和尾部插入或删除元素。
   - 插入和删除的复杂度为 **O(1)**。
2. **动态扩展：**
   - 像 `std::vector` 一样支持动态扩展。
3. **随机访问：**
   - 支持随机访问，复杂度为 **O(1)**，类似于数组。
4. **内存管理：**
   - `std::deque` 的内部实现不是连续的内存块，而是分段的内存块，这使得在两端插入元素更高效。

### 常用函数

以下是 `std::deque` 的常用函数及其功能：

#### 构造函数

| 函数名                               | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `deque()`                            | 创建一个空的双端队列。                                       |
| `deque(size_t n)`                    | 创建一个大小为 `n` 的双端队列，每个元素使用默认构造函数初始化。 |
| `deque(size_t n, const T& val)`      | 创建一个大小为 `n` 的双端队列，每个元素初始化为 `val`。      |
| `deque(std::initializer_list<T> il)` | 使用初始化列表构造双端队列。                                 |
| `deque(const deque& d)`              | 拷贝构造函数，创建一个双端队列的副本。                       |
| `deque(deque&& d)`                   | 移动构造函数，从另一个双端队列转移所有权。                   |

#### 容量相关函数

| 函数名                           | 作用                                                         | 时间复杂度 |
| -------------------------------- | ------------------------------------------------------------ | ---------- |
| `size()`                         | 返回双端队列中元素的数量。                                   | O(1)       |
| `empty()`                        | 检查双端队列是否为空，返回布尔值。                           | O(1)       |
| `resize(size_t n)`               | 调整双端队列的大小为 `n`，如果增加元素，则用默认值初始化新元素。 | O(n)       |
| `resize(size_t n, const T& val)` | 调整大小为 `n`，新元素用 `val` 初始化。                      | O(n)       |
| `max_size()`                     | 返回容器能容纳的最大元素个数。                               | O(1)       |

#### 元素访问

| 函数名             | 作用                                 | 时间复杂度 |
| ------------------ | ------------------------------------ | ---------- |
| `at(size_t index)` | 返回指定位置的元素，并进行越界检查。 | O(1)       |
| `operator[]`       | 返回指定位置的元素，不进行越界检查。 | O(1)       |
| `front()`          | 返回队列头部的第一个元素。           | O(1)       |
| `back()`           | 返回队列尾部的最后一个元素。         | O(1)       |

#### 修改函数

| 函数名                                 | 作用                                             | 时间复杂度 |
| -------------------------------------- | ------------------------------------------------ | ---------- |
| `push_back(const T& val)`              | 在队列尾部添加元素 `val`。                       | O(1)       |
| `push_front(const T& val)`             | 在队列头部添加元素 `val`。                       | O(1)       |
| `pop_back()`                           | 移除队列尾部的元素。                             | O(1)       |
| `pop_front()`                          | 移除队列头部的元素。                             | O(1)       |
| `insert(iterator pos, const T& val)`   | 在指定位置 `pos` 插入元素 `val`。                | O(n)       |
| `emplace_back(args...)`                | 在队列尾部直接构造元素（避免拷贝或移动）。       | O(1)       |
| `emplace_front(args...)`               | 在队列头部直接构造元素。                         | O(1)       |
| `emplace(iterator pos, args...)`       | 在指定位置 `pos` 直接构造元素。                  | O(n)       |
| `erase(iterator pos)`                  | 移除指定位置的元素。                             | O(n)       |
| `erase(iterator first, iterator last)` | 移除范围 `[first, last)` 的元素。                | O(n)       |
| `clear()`                              | 清空队列的所有元素。                             | O(n)       |
| `swap(deque& other)`                   | 交换当前双端队列和另一个双端队列的内容（高效）。 | O(1)       |

------

### **示例代码**

#### **1. 基本使用**

```cpp
#include <iostream>
#include <deque>
using namespace std;

int main() {
    deque<int> dq;

    // 插入元素
    dq.push_back(10);  // 插入到尾部
    dq.push_front(20); // 插入到头部
    dq.push_back(30);

    // 访问元素
    cout << "Front: " << dq.front() << endl; // 输出 20
    cout << "Back: " << dq.back() << endl;   // 输出 30

    // 移除元素
    dq.pop_front(); // 移除头部
    dq.pop_back();  // 移除尾部

    // 查看元素
    cout << "Front after pop: " << dq.front() << endl; // 输出 10

    return 0;
}
```

**输出：**

```
Front: 20
Back: 30
Front after pop: 10
```

### 复杂度总结

| 操作               | 时间复杂度 |
| ------------------ | ---------- |
| 插入（头部或尾部） | O(1)       |
| 删除（头部或尾部） | O(1)       |
| 随机访问           | O(1)       |
| 中间插入或删除     | O(n)       |

### 适用场景

- ```
  std::deque
  ```

   适合以下场景：

  1. **频繁的头部或尾部插入与删除**。
  2. **需要随机访问元素**。
  3. **不需要保证内存连续性**（与 `std::vector` 不同）。

### 347.前 K 个高频元素

感觉这道题有点复杂，没有拿下，明天再解决

相关知识如下

### **小顶堆和大顶堆的解释**

堆（Heap）是一种特殊的二叉树结构，用于快速实现**优先队列**功能。在堆中，元素按照特定的顺序规则组织，主要分为以下两类：

------

### **1. 小顶堆（Min Heap）**

#### **定义**

- 小顶堆是一种

  完全二叉树

  ，满足以下性质：

  - **每个节点的值都小于等于其子节点的值**。
  - 根节点（堆顶）的值是堆中的最小值。

#### **性质**

- 堆顶元素始终是最小值。
- 用于快速获取最小值（O(1) 时间复杂度）。

#### **操作**

- **插入元素：** 将新元素插入堆尾，然后调整堆使其保持小顶堆性质（上浮操作，O(log n)）。
- **删除堆顶：** 删除根节点（最小值），然后用堆尾元素替代堆顶，并调整堆使其保持小顶堆性质（下沉操作，O(log n)）。

#### **小顶堆示例**

构造一个小顶堆的数组 `[2, 5, 8, 10, 15, 20]`，堆的结构如下：

```
      2
     / \
    5   8
   / \
  10  15
       \
       20
```

**堆的性质：**

- 每个父节点小于等于其子节点。
- 堆顶 `2` 是最小值。

------

### **2. 大顶堆（Max Heap）**

#### **定义**

- 大顶堆是一种

  完全二叉树

  ，满足以下性质：

  - **每个节点的值都大于等于其子节点的值**。
  - 根节点（堆顶）的值是堆中的最大值。

#### **性质**

- 堆顶元素始终是最大值。
- 用于快速获取最大值（O(1) 时间复杂度）。

#### **操作**

- **插入元素：** 将新元素插入堆尾，然后调整堆使其保持大顶堆性质（上浮操作，O(log n)）。
- **删除堆顶：** 删除根节点（最大值），然后用堆尾元素替代堆顶，并调整堆使其保持大顶堆性质（下沉操作，O(log n)）。

#### **大顶堆示例**

构造一个大顶堆的数组 `[20, 15, 10, 8, 5, 2]`，堆的结构如下：

```
      20
     /  \
    15   10
   / \
  8   5
       \
        2
```

**堆的性质：**

- 每个父节点大于等于其子节点。
- 堆顶 `20` 是最大值。

------

### **小顶堆和大顶堆的比较**

| 特性           | 小顶堆                   | 大顶堆                   |
| -------------- | ------------------------ | ------------------------ |
| 堆顶元素       | 最小值                   | 最大值                   |
| 优先级应用     | 低值优先处理             | 高值优先处理             |
| 插入复杂度     | O(log n)                 | O(log n)                 |
| 删除堆顶复杂度 | O(log n)                 | O(log n)                 |
| 常见用途       | 实现优先队列，处理最小值 | 实现优先队列，处理最大值 |

C++ 提供了 `std::priority_queue`，默认是大顶堆，可以通过自定义比较器实现小顶堆。

### 堆的典型应用场景

1. **优先队列：**
   - 使用堆管理任务优先级，处理最高（大顶堆）或最低优先级（小顶堆）的任务。
2. **Top K 问题：**
   - 使用小顶堆或大顶堆快速找到数组中最大的 K 个元素或最小的 K 个元素。
3. **合并多个有序列表：**
   - 使用小顶堆合并多个有序链表或数组。
4. **动态中位数：**
   - 使用两个堆（一个小顶堆、一个大顶堆）动态维护中位数。



